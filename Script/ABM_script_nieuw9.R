

######NECESSARY PACKAGES###### 
library(ggplot2) #for the function remove missing and for visualizing 
library(truncnorm) # for truncated distrubution for the angles
library(compiler)
library(parallel) #for parallel computation




####run het model in 1 keer meerdere malen
iteratie<-351
iteratiestotaal<-361
while(iteratie < iteratiestotaal){
  
  




##environment parameter
nTree <-300 #number of trees
env_xmin<-0
env_xmax<-2000
env_ymin<-0
env_ymax<-2000

#fruiting parameters
AverageRegenSteps <-18980 #mean time steps for trees to refruit. (365 days=365*13*4=18980)
SdRegenSteps<-00 #sd refruiting time steps

#Trees have 10 fruit slots
#Fruit_p<- rtruncnorm(1, a = 0, b = 1, mean = Fruit_p_mean, sd=Fruit_p_sd)
Fruit_max <- 60 #total number of fruit slots
Fruit_p_mean<-0.7 #Trees have 10 fruit slots. Fruit_p is the probability that a fruit-slot will start growing a fruit. Each tree has it's own fruit probability that is generated by rnorm. Fruit_p_mean is the mean. A higher Fruit_p_mean -> environment with trees that hold more fruits (with a max of 10 fruits per tree each fruiting period)
Fruit_p_sd<- 0.15 

steps_to_ripen<- 3120 #In 60 dagen bereikt het fruit een waarde van 100 (value to ripen) -> 13*4*60 = 3120 stappen. Bajinath & Ramcharun, 1983; Eisikowitch, 1968; Piedra-Malag√≥n et al,2019 
decay_start<- 95 #after which ripeness threshold fruit starts to decay.
steps_to_decay<-520 #Niet meer eetbaar na 4 dagen van het rijp worden. Dus na 13*4*4= 208 stappen

#competitor parameter
edibility<-60 #ripeness thresshold from which competitors can eat
nPop <-10 #number of competitors 
visual_det_range<- 100 # (in m) visual detection range for all agents (both agent & primate_agent)
eat_range<-  5 # (in m) distance to an tree from which an agent can start eating (both agent & primate_agent)

#primate parameters
edibilityPrim <- 95
unripe_threshold <- 30 #edibility threshold from which an unripe fruit can be noticed by prim agent.

#memory parameters
scalarproptimeval<- 0.20 #value between 0-0.2. for the scalar proporty of time. value of 0.2 is inaccurate, while a value of 0.00001 is higly accurate. 
mem_length_ts<- 6240 #number of timesteps that a memory of a location will be kept (before forgetting). #in 90 dagen tijd vergeet de primaat de locatie,.ie. in 120*13*4=6240 stappen- steps_to_forget 
memory_slots<-5 #didnt check if it already works when I use more slots.

return_later<-52 #if agent sees that a remembered tree still contains unripe fruit, it will be in the memory but it will not be a target at that moment.First the prim agent will guess how many steps are needed, but if these steps are less than 1 day, the guess will become 52 steps. 
nr_unripe_threshold<-30 #if a primagent sees a tree with unripe fruits, the tree will need at least this number of fruits to place it in the memory

index_threshold<-26#index threshold when to make a memory a target. this is a half day = 13*4*0.5=26 the index is calculated by guessing the time necessary for a unripe fruit to fruit minus the distance between the agent and the tree. 

#random movement parameters
#stepsize parameters
#rnorm(1, mean = stepmean, sd = stepsd)
stepsize_mean<- 65 
stepsize_sd<- 10

#angle parameters (correlated random walk)
#rtruncnorm(1,a=-359,b=359, mean=0, sd=50)
angle_sd<-50




######CREATING Agents###### 
#Xcoord
#Ycoord
#sat is not being used anympre
#eaten keeps track how many fruits are eaten by each agent
Agent <- cbind(AgentNo = 1:nPop, Xcoord = runif(nPop,env_xmin,env_xmax),Ycoord= runif(nPop,env_ymin,env_ymax), eaten=0)




######CREATING Food_trees######
#Creating locations of food.
Fruit_p= rtruncnorm(1, a=0,b=1, mean = Fruit_p_mean, sd=Fruit_p_sd)
Trees<-NULL

#Create Trees throughout map
for(i in 1:nTree){
  Fruit_p= rtruncnorm(1, mean = 0.5, sd=0.09)
  Tree2 <- data.frame(TreeNo = i, Xcoord = runif(1,env_xmin,env_xmax),Ycoord= runif(1,env_ymin,env_ymax), Regenaration=round(rnorm(1, mean =  AverageRegenSteps, sd=SdRegenSteps)), 
                      fruit_prob = Fruit_p, Fruit_total_90= 0, Regen_counter=0, Fruit_total_95=NA, Unripe=NA,Fruits_created=0)
  Tree2[1,7] <- Tree2[1,4]-sample(x=1:Tree2[1,4],1,replace=T)
  Trees <- rbind(Trees, Tree2)
}



#Create Fruits on the Trees

v1 <- cbind( 1-Trees[,5], Trees[,5])
v1.list <- split(v1, seq(nrow(v1)))

FruitC<-matrix(rep(0,nTree*Fruit_max), nrow=nTree, ncol=Fruit_max) #fruit creating
FruitC <- t(FruitC)

FruitR<- matrix(rep(1,nTree*Fruit_max), nrow=nTree, ncol=Fruit_max) #ripening
FruitD<- matrix(rep(100,nTree*Fruit_max), nrow=nTree, ncol=Fruit_max) #decay

Fruits<- array(c(FruitC,FruitR,FruitD), c(nTree,Fruit_max,3))





Trees[,6] <- apply(Fruits[,,2]>edibility,1, sum)
Trees[,8] <- apply(Fruits[,,2]>edibilityPrim,1, sum)
Trees[,9] <- apply(Fruits[,,2]>unripe_threshold & Fruits[,,2]<edibilityPrim,1, sum)

Trees<- as.matrix(Trees)



rm(FruitC)
rm(FruitD)
rm(FruitR)
rm(v1.list)
rm(v1)



######Function for finding the distance between two locations######
#a_x= x coordinates of a 
#a_y= y coordinates of a 
#b_x= x coordinates of b 
#b_y= y coordinates of b 
distance <- function(x1, y1, x2, y2){sqrt((x1-x2)^2 + (y1-y2)^2)}





######Function for determining the angle between two locations######
anglefun <- function(x1,y1,x2,y2,bearing=TRUE,as.deg=TRUE){
  ## calculates the compass bearing of the line between two points
  ## xx and yy are the differences in x and y coordinates between two points
  ## Options:
  ## bearing = FALSE returns +/- pi instead of 0:2*pi
  ## as.deg = TRUE returns degrees instead of radians
  xx<-x1-x2
  yy<-y1-y2
  c = 1
  if (as.deg){
    c = 180/pi
  }
  
  b<-sign(xx)
  b[b==0]<-1  #corrects for the fact that sign(0) == 0
  tempangle = b*(yy<0)*pi+atan(xx/yy)
  if(bearing){
    #return a compass bearing 0 to 2pi
    #if bearing==FALSE then a heading (+/- pi) is returned
    tempangle[tempangle<0]<-tempangle[tempangle<0]+2*pi
  }
  return(tempangle*c)
}








######Function for moving toward food or eating######
#Input arguments are:
# agent         dataframe of the agents
# food          dataframe of foodtrees
# history       list that contains the dataframe of the agents for each timestep of simulation. 
# xloc_agent    column number of x coordinates of agents
# yloc_agent    column number of y coordinates of agents
# xloc_food     column number of x coordinates of foodtrees
# yloc_food     column number of y coordinates of foodtrees
# fruit         column number of number of edible fruits in tree (ripeness >90)
# visdet        visual detection range of agent
# xmin          lower x boundary that agent can access
# xmax          upper x boundary that agent can access
# ymin          lower y boundary that agent may not pass
# ymax          upper y boundary that agent can access


#Should rename fruit to fruit_col_agent, fruit_95 to fruit_col_prim

move <-function(agent, food, fruits, history, timestep, xloc_agent =2, yloc_agent=3, 
                xloc_food =2, yloc_food=3, fruit_col_agent= 6, 
                fruit_col_prim= 8,
                fruit_unripe=9, visdet=visual_det_range, xmin = env_xmin, 
                xmax=env_xmax, ymin=env_ymin, ymax=env_ymax,stepmean=stepsize_mean, stepsd=stepsize_sd, 
                eatdist=eat_range, 
                fruit_dim_creation=1,
                fruit_dim_ripeness=2,
                fruit_dim_decay=3,
                eaten_col =4,
                ripe=edibility,
                ripe_prim=edibilityPrim,
                unripe_prim= unripe_threshold,
                ang_sd=angle_sd){
  
  no_ind <- length(agent[,xloc_agent]) #get number of individuals
  no_trees <- length(food[,xloc_food]) #get number of trees
  eaten <- NULL
  visualdetectionused <- NULL
  
  for(i in 1:no_ind){                                                                                                   # For each individual i in the array
    eaten<- "N"   
    visualdetectionused <- "N"
    random_moved <- "N"
    treedistances<-matrix(nrow = 0, ncol = 2)#data.frame("no"=NA, "distance"= NA)
    
    for(j in 1:no_trees){
      if(food[j,fruit_col_agent]>0){
        treedistances<- rbind(treedistances, cbind(j,   distance(food[j,xloc_food], food[j,yloc_food], agent[i, xloc_agent], agent[i, yloc_agent]) ))
        
      }
    }
    treedistances<-remove_missing(treedistances, na.rm = T)
    
    if(length(treedistances[,1])>0){                                                          #If there are trees with fruits
      closesttree<-min(treedistances[,2]);                                               #get the closer location of these food tree with fruits
      nr_closesttree<-as.numeric(treedistances[which.min(treedistances[,2]),1]);
      
      #First, if there is food in eating distance the agent will eat. Otherwise it will move
      if(closesttree<eatdist){
        eaten<-"Y"
        
        fruitcell<- which.max(fruits[nr_closesttree,,fruit_dim_ripeness])                        #the which function returns the first fruit that is ripe in the row
        
        fruits[nr_closesttree, fruitcell, fruit_dim_creation] <-0                                 #agent eats the fruit 
        fruits[nr_closesttree, fruitcell, fruit_dim_ripeness] <-1                                 #ripening cell gets reset for this fruit 
        fruits[nr_closesttree, fruitcell, fruit_dim_decay]    <-100                     
        
        
        #the total number of fruits that are edible for normal agents, for primate agents and the unripe fruits or memory should be recounted since some fruits have been eaten
        
        food[nr_closesttree,fruit_col_agent] <- sum( fruits[nr_closesttree,,fruit_dim_ripeness]> ripe)
        food[nr_closesttree,fruit_col_prim] <- sum( fruits[nr_closesttree,,fruit_dim_ripeness]> ripe_prim)
        food[nr_closesttree,fruit_unripe] <- sum(fruits[nr_closesttree,,fruit_dim_ripeness]> unripe_prim & fruits[nr_closesttree,,fruit_dim_ripeness]< ripe_prim)
        
        agent[i, eaten_col]<- agent[i, eaten_col] + 1                                         #every fruit that is eaten is counted for each agent
      }
      
      
      if(eaten=="N" && closesttree<visdet){                                                   #if the agent has not eaten and if there is a tree with edible fruit for the agent in visual detection range. It will move towards the closest tree 
        visualdetectionused <- "Y"
        if((agent[i,yloc_agent]-food[nr_closesttree,yloc_food]) == 0){                        #if the agent is at the same y coordinate, don't move in y direction. only in x direction towards closest food tree with fruit
          x_move <- closesttree*0.6
          y_move <- 0
          if(agent[i,xloc_agent]>food[nr_closesttree,xloc_food]){x_move<-x_move*-1}           #if the agent is on the right of the closest food location it needs to go to the left, i.e. multiply with -1
        }else if((agent[i,xloc_agent]-food[nr_closesttree,xloc_food])==0){                    #if the agent is at the same x coordinate, don't move in x direction. only in x direction towards closest food tree with fruit
          x_move <- 0
          y_move <- closesttree*0.6
          if(agent[i,yloc_agent]>food[nr_closesttree,yloc_food]){y_move<-y_move*-1}           #if the agent is above of the closest food location it needs to go to down, i.e. multiply with -1
        }else if((agent[i,yloc_agent]-food[nr_closesttree,yloc_food])!=0 && (agent[i,xloc_agent]-food[nr_closesttree,xloc_food])!=0){           #if the agent is not on the same y coordinate and neither on the same x coordinate
          angle<-(atan(abs((agent[i,yloc_agent]-food[nr_closesttree,yloc_food]))/abs((agent[i,xloc_agent]-food[nr_closesttree,xloc_food]))));
          x_move <-abs(cos(angle)*(closesttree*0.6));                                                                                  
          y_move <-abs(sin(angle)*(closesttree*0.6));
          
          if(agent[i,xloc_agent]>food[nr_closesttree,xloc_food]){x_move<-x_move*-1};
          if(agent[i,yloc_agent]>food[nr_closesttree,yloc_food]){y_move<-y_move*-1};
        }
        
        agent[i,xloc_agent] <- agent[i,xloc_agent] + x_move;
        agent[i,yloc_agent] <- agent[i,yloc_agent] + y_move; 
      }
    }
    
    #if agent has not eaten or used visual detection it will move randomly
    if(is.na(anglefun(history[[timestep - 1]][i,xloc_agent], history[[timestep - 1]][i,yloc_agent], history[[timestep]][i,xloc_agent], history[[timestep]][i,yloc_agent]))){  
      if(eaten=="N" && visualdetectionused == "N"){
        random_moved<- "Y"
        
        #Random movement if there is no food with fruit and if the last step was at the same location (i.e. the angle will be totally random)
        angle_movement<-sample(x=0:360,size=1);
        movementdistance<-rnorm(1, mean = stepmean, sd = stepsd);
        
        x_move <- sin(angle_movement*pi/180)*movementdistance;
        y_move <- cos(angle_movement*pi/180)*movementdistance; 
        
      }
    }else{
      if(eaten=="N" && visualdetectionused == "N"){
        
        random_moved<- "Y"
        #Random movement if there is no food with fruit
        angle_movement<- anglefun(history[[timestep - 1]][i,xloc_agent], history[[timestep - 1]][i,yloc_agent], history[[timestep]][i,xloc_agent], history[[timestep]][i,yloc_agent]) + rtruncnorm(1,a=-359,b=359, mean=0, sd=ang_sd)
        movementdistance<-rnorm(1, mean = stepmean, sd = stepsd);
        
        x_move <- sin(angle_movement*pi/180)*movementdistance;
        y_move <- cos(angle_movement*pi/180)*movementdistance;
      }      
    }
    
    if(random_moved == "Y"){
      # =========   The reflecting boundary is added below
      if( (agent[i,xloc_agent] + x_move) > xmax || (agent[i,xloc_agent] + x_move) < xmin){   # If it moved passed the maximum or minimum xloc
        agent[i, xloc_agent] <- agent[i,xloc_agent] - x_move; # Then just do x_move in the negative
      }else{agent[i,xloc_agent] <- agent[i,xloc_agent] + x_move}
      
      if( (agent[i, yloc_agent] + y_move) > ymax || (agent[i, yloc_agent] + y_move) < ymin){  # If it moved passed the maximum or minimum yloc
        agent[i,yloc_agent] <- agent[i,yloc_agent] - y_move; # Then just do x_move in the negative
      }else{agent[i,yloc_agent] <- agent[i,yloc_agent] + y_move}
    }
    
  }
  return(list(agent,food,fruits))  
}






######Function for ripening of fruit######

#het moet een s-curve worden die van 0 naar de 100 gaat. 
#bij x=0 -> y= 1
#y=c/ (1+ae^-bx)
#In 10 dagen bereikt het een waarde van 95  -> 13*4*10 = 540 stappen

#y=bx
#b=100/3120
#in 60 dagen wordt de 100 waarde bereikt. 
#value_to_ripen<-100


ripen<-function(y_value, b_value=(100/steps_to_ripen), ripeningsteps=steps_to_ripen){
  x_value<-NULL
  x_value   <- y_value/b_value
  x_new     <- x_value+1
  
  y_value   <-  b_value*x_new
  
  return(y_value);
  }




fruitripening <-function(food, fruits, xloc_food=2,  
                         fruit_dim_creation=1,
                         fruit_dim_ripeness=2,
                         fruit_dim_decay=3,
                         #decay_col1 = 5, decay_col2 = 6, decay_col3 =7, 
                         ripeningsteps=steps_to_ripen, 
                         ripe=edibility,
                         ripe_prim=edibilityPrim,
                         unripe_prim= unripe_threshold,
                         fruit_col_agent= 6,
                         fruit_col_prim= 8,
                         fruit_unripe=9){
  no_trees <- length(food[,xloc_food]);                                 #get number of trees
  no_fruits<-length(fruits[1,,1])

  
  for(i in 1:no_trees){                                                 #for each tree 
    
    for(j in 1:no_fruits){                                              #for each fruit item in tree: (there are 10 rows reserved for possible fruits).
      if(fruits[i, j, fruit_dim_creation]==1){                          #if thefruit is in the process of being created (i.e. col1 is 1 )
        fruits[i, j, fruit_dim_ripeness]<-ripen(fruits[i, j, fruit_dim_ripeness])
      }
    }
  } 
  
  #the total number of fruits that are edible for normal agents, for primate agents and the unripe fruits or memory should be recounted
  food[,fruit_col_agent] <- apply(fruits[,,fruit_dim_ripeness]>ripe,1, sum)
  food[,fruit_col_prim] <- apply(fruits[,,fruit_dim_ripeness]>ripe_prim,1, sum)
  food[,fruit_unripe] <-apply(fruits[,,fruit_dim_ripeness]>unripe_prim & fruits[,,fruit_dim_ripeness]<ripe_prim,1, sum)

  
  
  return(list(food,fruits));
}




 





#decaysteps  number of steps after which the fruit is completely inedibile. Niet meer eetbaar na 4 dagen van het rijp worden. Dus na 13*4*4= 208 stappen
decay<-function(y_value, decaysteps=steps_to_decay){
  a_value  <- (-100/decaysteps);
  b_value  <- 100;
  #formula is y=(-100/208)*x+100
  x_value <- (y_value-b_value)/a_value
  x_new   <- x_value+1 
  y_value <- (a_value*x_new) + b_value
  #y_value<- y_value*(-100/decaysteps)
  
  return(y_value);
}






######Function for decay of fruit######

#decay_col1,2,3, are the column numbers for the first fruit of a tree in the dataframe.
fruitdecay <- function(food, fruits, xloc_food=2, 
                       fruit_dim_creation=1,
                       fruit_dim_ripeness=2,
                       fruit_dim_decay=3,
                       decay_str=decay_start,
                       ripe=edibility,
                       ripe_prim=edibilityPrim,
                       unripe_prim= unripe_threshold,
                       fruit_col_agent= 6,
                       fruit_col_prim= 8,
                       fruit_unripe=9){                                                        
  no_trees <- length(food[,xloc_food]);                                   #get number of trees
  no_fruits<-length(fruits[1,,1])                                         #get number of trees
  
  
  for(i in 1:no_trees){                                         #for each tree 
    
    for(j in 1:no_fruits){                                             #for each fruit item in tree
      
      if(fruits[i, j, fruit_dim_creation]==1 && fruits[i, j, fruit_dim_ripeness] >= decay_str){         #decaying process only starts if a fruit is in the process of being created (i.e. col1 is 1 ) and after fruit has ripened i.e. 90>
        fruits[i, j, fruit_dim_decay]<-decay(fruits[i, j, fruit_dim_decay])
      }  
      
      if(fruits[i, j, fruit_dim_decay]<=0){
        fruits[i, j, fruit_dim_creation]<-0;                #if the fruit is rotten than there should be no more food -> the value at column should become zero 
        fruits[i, j, fruit_dim_ripeness]<-1;                #and the ripening process should be reset to 1 value
        fruits[i, j, fruit_dim_decay]   <-100;              #and the decayprocess should be reset to 100 value     
      }
    }  
  }
  
  food[,fruit_col_agent] <- apply(fruits[,,fruit_dim_ripeness]>ripe,1, sum)
  food[,fruit_col_prim] <- apply(fruits[,,fruit_dim_ripeness]>ripe_prim,1, sum)
  food[,fruit_unripe] <-apply(fruits[,,fruit_dim_ripeness]>unripe_prim & fruits[,,fruit_dim_ripeness]<ripe_prim,1, sum)
  
  return(list(food,fruits));
}







######Function for fruiting of trees######
fruiting <- function(food, fruits, xloc_food=2, 
                     fruit_dim_creation=1,
                     fruit_dim_ripeness=2,
                     fruit_dim_decay=3,
                     regen_col=4, 
                     fruit_prob=5, 
                     regen_counter=7, 
                     ripe=edibility,
                     ripe_prim=edibilityPrim,
                     unripe_prim= unripe_threshold,
                     fruit_col_agent= 6,
                     fruit_col_prim= 8,
                     fruit_unripe=9,
                     total_fruits=10
                     ){
  no_trees <- length(food[,xloc_food]); 
  no_fruits<-length(fruits[1,,1]) 
  
  for(i in 1:no_trees){                                                               #for each tree
    
    if(food[i,regen_counter]>0){                                                       #if the counter has not yet reached zero
      food[i,regen_counter]<-food[i,regen_counter] -1                                   #then decrease counter with 1
    }else{
      food[i,regen_counter]<-food[i,regen_col]  
      
      probab<-cbind( 1-food[i,fruit_prob], food[i,fruit_prob])
      probab.list<- split(probab, seq(nrow(probab)))
      
      fruits[i,,fruit_dim_creation]<-t(mapply(list(c(0,1)), size=Fruit_max, replace = TRUE,prob=probab.list,FUN=sample))
      fruits[i,,fruit_dim_ripeness]<-1
      fruits[i,,fruit_dim_decay]<-100
      
      food[i,total_fruits]<-food[i,total_fruits] + sum(fruits[i,,fruit_dim_creation]) # keep track of total number of created fruits in each tree
    }
  }
  
  food[,fruit_col_agent] <- apply(fruits[,,fruit_dim_ripeness]>ripe,1, sum)
  food[,fruit_col_prim] <- apply(fruits[,,fruit_dim_ripeness]>ripe_prim,1, sum)
  food[,fruit_unripe] <-apply(fruits[,,fruit_dim_ripeness]>unripe_prim & fruits[,,fruit_dim_ripeness]<ripe_prim,1, sum)
  
  
  return(list(food,fruits));
}






#starts in the middle of the landscape
Primate_agent <- cbind(AgentNo = 1, Xcoord = (env_xmax-env_xmin)/2,Ycoord= (env_ymax-env_ymin)/2, eaten=0)

#####Dataframe for temporally remembered locations
#let agent only temporally remember one location
#how many remembered is added to check
#target_count is to check how many times something is made a target
#index value in which it is based whether something is made a target
Temporal_remembered <-   cbind(RememberedNo = 1:memory_slots, Tree_no= 0, Xcoord = 0,Ycoord= 0,forget_counter=0, target=0,howmany=0, counter_to_ripen=0,target_count=0, index=1000)





scalarpropertyfun<- function(y_value,b_value=(100/steps_to_ripen), ripeningsteps = steps_to_ripen, bwaarde=scalarproptimeval, edibile=edibilityPrim){
  x_value<-NULL
  y_difference<-edibilityPrim-y_value
  x_value   <- y_difference/b_value #this is the number of steps until fruit will reach 100
  
  
  
  standaarddev<-0+bwaarde*(ripeningsteps-x_value)    
  
  scalar_value <- x_value-rnorm(n=1, mean=0, sd=standaarddev)
  
  return(scalar_value);
}




# steps_to_forget: #in 90 dagen tijd vergeet de primaat de locatie

#####Function for remembering UNRIPE FRUIT LOCATIONS#####
Remembertemporal <- function(prim_agent, food, fruits, remembered, xloc_agent =2, yloc_agent=3, 
                             xloc_food =2, yloc_food=3, 
                             visdet=visual_det_range, 
                             xmin = env_xmin, xmax=env_xmax, ymin=env_ymin, ymax=env_ymax, 
                             fruit_unripe=9, 
                             remembered_tree_no=2,
                             remembered_tree_x=3, 
                             remembered_tree_y=4, 
                             Steps_to_forget=mem_length_ts,
                             forget_counter=5, 
                             counter_to_ripen_col=8,  
                             ripeningsteps = steps_to_ripen,
                             memories_nr_counter=7,
                             fruit_dim_ripeness=2,
                             nr_unripe_thresh=nr_unripe_threshold){
  
  emptyslot<-NULL
  no_trees <- length(food[,xloc_food]) #get number of trees
  no_remembered <- length(remembered[,1])
  
  treedistances_unripe <-matrix(ncol=2,nrow=0)
  colnames(treedistances_unripe) <- c("no","distance")
  
  
  for(i in 1:no_trees){
    if(food[i,fruit_unripe]>nr_unripe_thresh){                                                           #afstanden bepalen naar bomen met onrijp fruit. Er moeten wel meer dan remember_threshold fruit in de boom zijn 
      treedistances_unripe<- rbind(treedistances_unripe,cbind(i,distance(food[i,xloc_food], food[i,yloc_food], prim_agent[1, xloc_agent], prim_agent[1, yloc_agent])))
    }  
    treedistances_unripe<-remove_missing(treedistances_unripe, na.rm = T)
  }
  
  
  if(length(treedistances_unripe[,1])>0){                                                                                       #if there are trees with unripe fruits.
    closesttree_unripe<-min(treedistances_unripe[,2]);                                                                          #of trees with unripe fruit get the closest location
    nr_closesttree_unripe<-as.numeric(treedistances_unripe[which.min(treedistances_unripe[,2]),1]);
    
    if(all(remembered[,remembered_tree_no] !=  nr_closesttree_unripe)){                                                        #only if a location is not already remembered, it should be placed in their memory list
                                         
      if(closesttree_unripe<visdet && sum(sign(remembered[,forget_counter]))<no_remembered){                                                #if the closest tree with unripe fruits is in the visual detection range and if there is slot free to remember
        emptyslot<-which.min(remembered[,remembered_tree_no])                                                                   #find slot that is empty to place a memory in
        remembered[emptyslot,remembered_tree_no]  <-nr_closesttree_unripe
        remembered[emptyslot,remembered_tree_x]   <-food[nr_closesttree_unripe,xloc_food]
        remembered[emptyslot,remembered_tree_y]   <-food[nr_closesttree_unripe,yloc_food]
        remembered[emptyslot,forget_counter]      <-Steps_to_forget                                                             #after this number of steps the memory will be forgotten
                                                                                                                                #find the ripening state of one of the fruits of the tree
        remembered[emptyslot,counter_to_ripen_col]<-scalarpropertyfun(max(fruits[nr_closesttree_unripe,,fruit_dim_ripeness]))   #determine how many steps the primagent thinks it will take for the fruit to ripen
        remembered[emptyslot,memories_nr_counter]<- remembered[emptyslot,memories_nr_counter] + 1                               #count how many memories are placed in each memory slot
      }
      
    }  
  }
  return(remembered)
}  






#####Function for forgetting UNRIPE FRUIT LOCATIONS#####
forgetting <- function(remembered,forget_counter=5, counter_to_ripen_col=8){
  no_remembered <- length(remembered[,forget_counter]);                       #number of slots to remember
  
  for(i in 1:no_remembered){
    if(remembered[i,forget_counter]>0){                                          #if the forget counter is still higher than 0
      remembered[i,forget_counter]<- remembered[i,forget_counter]-1              #than the forget counter should decrease with 1
    }else{                                        #if it is not above 0 the remembered slot should be reset, i.e. the locations should be forgot
      remembered[i,2]<-0
      remembered[i,3]<-0
      remembered[i,4]<-0
      remembered[i,5]<-0
      remembered[i,6]<-0   
      
      remembered[i,8]<-0   
      
      remembered[i,10]<-1000  
    }
    #similarly the counter to ripen should also decrease every step. However, that does not need to reset when zero is reached
    if(remembered[i,counter_to_ripen_col]>0){
      remembered[i,counter_to_ripen_col]<- remembered[i,counter_to_ripen_col]-1 
    }
    
  }
  
  return(remembered)  
}







#####Function for visually updating memory/discarding memory ##### 
#####Combined with function with making it not a target anymore#####
#if agent sees that a remembered tree does not contain unripe fruit anymore it will discard the memory (or if it sees that the fruit is ripe. Then it will just go to it and eat the fruit.) 
#if agent sees that a remembered tree still contains unripe fruit, it will be in the memory but it will not be a target at that moment and 54 (1day) will be added to the counter to make it less likely that it will immediately make it a target

discard_mem <- function(prim_agent, food, fruits, remembered, 
                        xloc_agent =2, yloc_agent=3,
                        remembered_tree_no=2, 
                        remembered_xloc=3, remembered_yloc=4, 
                        visdet=visual_det_range, fruit_unripe=9, 
                        forget_counter=5, target=6, 
                        counter_to_ripen_col=8, ret_later=return_later,
                        fruit_dim_ripeness=2){
  no_remembered <- length(remembered[,1])
  treedistance_remembered <- NULL
  
  
  #DETERMINING DISTANCE TO TREES THAT ARE REMEMBERED
  for(i in 1:no_remembered){
    treedistance_remembered <- distance(remembered[i,remembered_xloc], remembered[i,remembered_yloc], prim_agent[1, xloc_agent], prim_agent[1, yloc_agent])
    
    #if there is a tree remembered in the slot & if it is in visual distance 
    if(remembered[i,remembered_tree_no] != 0 && treedistance_remembered<visdet && food[remembered[i,remembered_tree_no],fruit_unripe]==0){
      
      if(food[remembered[i,remembered_tree_no],fruit_unripe]==0){           #if it does not contain unripe fruit anymore then the memory should be reset, since this means that the fruit is ripe then it will move toward it due to seeing it, or it will be empty by now and then the memory slot should also be emptied
        remembered[i,remembered_tree_no]  <- 0
        remembered[i,remembered_xloc]  <- 0    
        remembered[i,remembered_yloc]  <- 0    
        remembered[i,forget_counter]  <- 0    
        remembered[i,target]  <- 0
        remembered[i,counter_to_ripen_col]  <- 0
        remembered[i,10]  <- 1000
      }else{                                                                #if it still contains unripe fruit 
        if(remembered[i,target]==1){                                        #and if it was a target
          remembered[i,target]  <- 0                                        #untarget it
          remembered[i,counter_to_ripen_col]<-scalarpropertyfun(max(fruits[remembered_tree_no,,fruit_dim_ripeness])) #the agent makes another guess when it will ripe. 
          if(remembered[i,counter_to_ripen_col]<ret_later){remembered[i,counter_to_ripen_col]<-ret_later} #If this is lower than a day in the future. Then make the guess a day in the future instead of guessing (in order for the location not immediately being a target).
          
        }                                                                    
      }
    }
  }
  
  return(remembered)  
}





















#####Movement of Primate Agent#####
#ripe, when food is counted as ripe for this. if fruit is 95 ripe.
move_primate <- function(prim_agent, food, fruits, remembered, history, timestep,
                         xloc_agent =2, yloc_agent=3, xloc_food =2, yloc_food=3, 
                         fruit_col_agent= 6,
                         fruit_col_prim= 8,
                         fruit_unripe=9, 
                         visdet=visual_det_range, 
                         xmin = env_xmin, xmax=env_xmax, ymin=env_ymin, ymax=env_ymax, 
                         stepmean=stepsize_mean, stepsd=stepsize_sd, 
                         remembered_tree_no=2, 
                         remembered_tree_x=3, remembered_tree_y=4, 
                         eatdist=eat_range, 
                         fruit_dim_creation=1,
                         fruit_dim_ripeness=2,
                         fruit_dim_decay=3,
                         eaten_col =4,
                         ripe=edibility,
                         ripe_prim=edibilityPrim,
                         unripe_prim= unripe_threshold, 
                         target=6,
                         remembered_xloc=3, remembered_yloc=4, forget_counter=5, Steps_to_forget=mem_length_ts, ripe_competitor=edibility, 
                         index_thresh=index_threshold, 
                         counter_to_ripen_col=8, ang_sd= angle_sd){
  
  no_trees <- length(food[,xloc_food]) #get number of trees
  no_remembered <- length(remembered[,1])  #get number of slots in memory
  
  treedistances_ripe <-matrix(ncol=2,nrow=0)
  colnames(treedistances_ripe) <- c("no","distance")
  
  treedistance_remembered <- NULL
  nr_target <- NULL
  distance_target <- NULL
  indices <- cbind("no"=c(NA,NA,NA,NA,NA), "value"= NA, "below_7"= NA, "abs_values"=NA) 
  maxdist <- sqrt(xmax^2+xmax^2)
  chosen_target<-NULL
  
  eaten <- "N"
  visualdetectionused <- "N"
  memory_used <- "N"
  random_moved <- "N"
  
  
  #DETERMINING DISTANCE TO TREES WITH FRUITS
  for(i in 1:no_trees){
    if(food[i,fruit_col_prim]>0){              
      treedistances_ripe<- rbind(treedistances_ripe,cbind(i,distance(food[i,xloc_food], food[i,yloc_food], prim_agent[1, xloc_agent], prim_agent[1, yloc_agent])))
    }
  }
  treedistances_ripe<-remove_missing(treedistances_ripe, na.rm = T)
  
  if(length(treedistances_ripe[,1])>0){                                                             #If there are trees with fruits
    closesttree_ripe<-min(treedistances_ripe[,2]);                                                  #get the closer location of these food tree with fruits
    nr_closesttree_ripe<-as.numeric(treedistances_ripe[which.min(treedistances_ripe[,2]),1]);            #and the number of this closest food tree
    
    #First, if there is food in eating distance the agent will eat. Otherwise it will move
    if(closesttree_ripe<eatdist){
      eaten<-"Y"
      fruitcell<-which.max(fruits[nr_closesttree_ripe,,fruit_dim_ripeness])                         #find the the first fruit of the tree with the highest ripeness (which is ripe because of the if statement before)
                                                                                                    #let agent eat 
      fruits[nr_closesttree_ripe, fruitcell, fruit_dim_creation] <-0                                 #agent eats the fruit 
      fruits[nr_closesttree_ripe, fruitcell, fruit_dim_ripeness] <-1                                 #ripening cell gets reset for this fruit 
      fruits[nr_closesttree_ripe, fruitcell, fruit_dim_decay]    <-100 
      

      #the total number of fruits that are edible for normal agents, for primate agents and the unripe fruits or memory should be recounted since some fruits have been eaten
      
      food[nr_closesttree_ripe,fruit_col_agent] <- sum( fruits[nr_closesttree_ripe,,fruit_dim_ripeness]> ripe)
      food[nr_closesttree_ripe,fruit_col_prim] <- sum( fruits[nr_closesttree_ripe,,fruit_dim_ripeness]> ripe_prim)
      food[nr_closesttree_ripe,fruit_unripe] <- sum(fruits[nr_closesttree_ripe,,fruit_dim_ripeness]> unripe_prim & fruits[nr_closesttree_ripe,,fruit_dim_ripeness]< ripe_prim)
      
      prim_agent[1, eaten_col]<- prim_agent[1, eaten_col] + 1                                         #every fruit that is eaten is counted for each agent
    }  
    
    
    ####VISUAL DETECTION PART#
    if(eaten == "N" && closesttree_ripe < visdet){                            #if the agent is hungry (i.e. if the satiatedness level is below 90) and if one of trees is in detection range. It will move towards the closest tree 
      visualdetectionused <- "Y"    
      if((prim_agent[1,yloc_agent]-food[nr_closesttree_ripe,yloc_food]) == 0){                        #if the agent is at the same y coordinate, don't move in y direction. only in x direction towards closest food tree with fruit
        x_move <- closesttree_ripe*0.6
        y_move <- 0
      }else if((prim_agent[1,xloc_agent]-food[nr_closesttree_ripe,xloc_food])==0){                    #if the agent is at the same x coordinate, don't move in x direction. only in x direction towards closest food tree with fruit
        x_move <- 0
        y_move <- closesttree_ripe*0.6
      }else if((prim_agent[1,yloc_agent]-food[nr_closesttree_ripe,yloc_food])!=0 && (prim_agent[1,xloc_agent]-food[nr_closesttree_ripe,xloc_food])!=0){           #if the agent is not on the same y coordinate and neither on the same x coordinate
        angle<-(atan(abs((prim_agent[1,yloc_agent]-food[nr_closesttree_ripe,yloc_food]))/abs((prim_agent[1,xloc_agent]-food[nr_closesttree_ripe,xloc_food]))));
        x_move <-abs(cos(angle)*(closesttree_ripe*0.6));                                                                                  
        y_move <-abs(sin(angle)*(closesttree_ripe*0.6));
      }
      
      if(prim_agent[1,xloc_agent]>food[nr_closesttree_ripe,xloc_food]){       
        x_move<-abs(x_move)*-1                                                            #if the agent is on the right of the closest food location it needs to go to the left, i.e. multiply with -1
      }else{x_move<-abs(x_move)} 
      
      if(prim_agent[1,yloc_agent]>food[nr_closesttree_ripe,yloc_food]){                   #if the agent is above of the closest food location it needs to go to down, i.e. multiply with -1
        y_move<-abs(y_move)*-1
      }else{y_move<-abs(y_move)}
      
      prim_agent[1,xloc_agent] <- prim_agent[1,xloc_agent] + x_move;          
      prim_agent[1,yloc_agent] <- prim_agent[1,yloc_agent] + y_move; 
    }
  }
  
  
  #EPISODIC MEMORY PART1#
  distance_pot_target<- NULL
  steps_to_target<- NULL
  timecounter_index<- NULL
  
  #if nothing has been eaten, no food has been visually detected, no memory is a target yet and if there is more than 0 memories
  if(eaten == "N" && visualdetectionused == "N" && sum(remembered[,target]) == 0 && sum(remembered[,2]) > 0){ 
    for(j in 1:no_remembered){
      if(remembered[j,2]>0){ #if the memory slot is not empty
        distance_pot_target   <- distance(remembered[j,remembered_xloc], remembered[j,remembered_yloc], prim_agent[1, xloc_agent], prim_agent[1, yloc_agent])
        steps_to_target <- round(distance_pot_target/stepmean)
        
        indices[j,1] <- j  
        indices[j,2] <- steps_to_target-remembered[j,counter_to_ripen_col]
        remembered[j,10] <- indices[j,2] #index value is also remembered, as a verification
        
      }else{
        indices[j,1] <- j
        indices[j,2] <- 1000 #if the memory slot is empty give it a high index value of a 1000 in order for it not to become a target
        remembered[j,10] <- indices[j,2] #index value is also remembered, as a verification
      }
    }
    
    indices[,4] <-abs(indices[,2])
    
    #if there are indices below 26(half a day), then make the one closest to 0 a target.
    indices[,3][indices[,4]<index_thresh] <- 1 # first make column indicating whether the values in column 2 are smaller than 26 or not
    indices[,3][indices[,4]>(index_thresh-1)] <- 0
    
    
    if(sum(indices[,3])>0 ){                 # if there are indices below 7
      chosen_target<-which.min(indices[,4])        # make the lowest index value the target( i.e. the one closest to zero, since absolute values are used)
      remembered[chosen_target,target]<-1
      remembered[chosen_target,9]<-remembered[chosen_target,9]+1 #counter to check how many times a memory is made a target
    }
    
  }
  
  #EPISODIC MEMORY PART2#
  if(eaten == "N" && visualdetectionused == "N" && sum(remembered[,target]) == 1){               #if no food is seen & if there are remembered locations & and if one of these has already been targeted
    memory_used <- "Y"    
    nr_target<-which.max(remembered[,target])
    distance_target <- distance(remembered[nr_target,remembered_tree_x], remembered[nr_target,remembered_tree_y], prim_agent[1,xloc_agent], prim_agent[1,yloc_agent])
    
    if((prim_agent[1,yloc_agent]-remembered[nr_target,remembered_tree_y]) == 0){                        #if the agent is at the same y coordinate, don't move in y direction. only in x direction towards remembered location
      if(distance_target>visdet){                                                                       #if the location is far away go with normal speed
        x_move <- rnorm(1, mean = stepmean, sd = stepsd);
      }else{
        x_move <- distance_target*0.6
      }
      y_move <- 0
      
    }else if((prim_agent[1,xloc_agent]-remembered[nr_target,remembered_tree_x]) == 0){
      if(distance_target>visdet){                                                                       #if the location is far away go with normal speed
        y_move <- rnorm(1, mean = stepmean, sd = stepsd);
      }else{
        y_move <- distance_target*0.6
      }
      x_move <- 0
      
    }else if((prim_agent[1,yloc_agent]-remembered[nr_target,remembered_tree_y]) != 0 && (prim_agent[1,xloc_agent]-remembered[nr_target,remembered_tree_x]) != 0){
      angle<-(atan(abs((prim_agent[1,yloc_agent]-remembered[nr_target,remembered_tree_y]))/abs((prim_agent[1,xloc_agent]-remembered[nr_target,remembered_tree_x]))));
      if(distance_target>visdet){  
        x_move <-abs(cos(angle)*(rnorm(1, mean = stepmean, sd = stepsd)));                                                                                  
        y_move <-abs(sin(angle)*(rnorm(1, mean = stepmean, sd = stepsd)));
      }else{
        x_move <-abs(cos(angle)*(distance_target*0.6));                                                                                  
        y_move <-abs(sin(angle)*(distance_target*0.6));
      }
    }
    
    if(prim_agent[1,xloc_agent]>remembered[nr_target,remembered_tree_x]){       
      x_move<-abs(x_move)*-1                                                                #if the agent is on the right of the closest food location it needs to go to the left, i.e. multiply with -1
    }else{x_move<-abs(x_move)} 
    
    if(prim_agent[1,yloc_agent]>remembered[nr_target,remembered_tree_y]){                   #if the agent is above of the closest food location it needs to go to down, i.e. multiply with -1
      y_move<-abs(y_move)*-1
    }else{y_move<-abs(y_move)}
    
    
    prim_agent[1,xloc_agent] <- prim_agent[1,xloc_agent] + x_move;
    prim_agent[1,yloc_agent] <- prim_agent[1,yloc_agent] + y_move;
    
  }
  
  
  
  
  ####RANDOM MOVEMENT PART# 
  #  #If at the last timepoint the agent was at the same location than a random angle is chosen.
  if(is.na(anglefun(history[[timestep - 1]][1,xloc_agent], history[[timestep - 1]][1,yloc_agent], history[[timestep]][1,xloc_agent], history[[timestep]][1,yloc_agent]))){  
    if(eaten == "N" && visualdetectionused == "N" && memory_used == "N"){                                #if no food is seen & memory is not used. Then just move randomly
      random_moved<- "Y"
      #Random movement if there is no food with fruit
      angle_movement<-sample(x=0:360,size=1);
      movementdistance<-rnorm(1, mean = stepmean, sd = stepsd);
      
      x_move <- sin(angle_movement*pi/180)*movementdistance;
      y_move <- cos(angle_movement*pi/180)*movementdistance; 
      
    }
    #  #If at the last timepoint the agent was not at the same location than the angle is partially dependent on the last location
  }else{
    if(eaten == "N" && visualdetectionused == "N" && memory_used == "N"){                                #if no food is seen & memory is not used. Then just move randomly
      random_moved<- "Y"
      #Random movement if there is no food with fruit
      angle_movement<- anglefun(history[[timestep - 1]][1,xloc_agent], history[[timestep - 1]][1,yloc_agent], history[[timestep]][1,xloc_agent], history[[timestep]][1,yloc_agent]) + rtruncnorm(1,a=-359,b=359, mean=0, sd=angle_sd)
      
      movementdistance<-rnorm(1, mean = stepmean, sd = stepsd);
      
      x_move <- sin(angle_movement*pi/180)*movementdistance;
      y_move <- cos(angle_movement*pi/180)*movementdistance; 
      
    }  
  }
  
  if(random_moved == "Y"){
    # =========   The reflecting boundary is added below
    if( (prim_agent[1,xloc_agent] + x_move) > xmax || (prim_agent[1,xloc_agent] + x_move) < xmin){   # If it moved passed the maximum or minimum xloc
      prim_agent[1,xloc_agent] <- prim_agent[1,xloc_agent] - x_move; # Then just do x_move in the negative
    }else{prim_agent[1,xloc_agent] <- prim_agent[1,xloc_agent] + x_move}
    
    if( (prim_agent[1,yloc_agent] + y_move) > ymax || (prim_agent[1,yloc_agent] + y_move) < ymin){  # If it moved passed the maximum or minimum yloc
      prim_agent[1,yloc_agent] <- prim_agent[1,yloc_agent] - y_move; # Then just do x_move in the negative
    }else{prim_agent[1,yloc_agent] <- prim_agent[1,yloc_agent] + y_move}
    
  }
  
  return(list(prim_agent,food,fruits,remembered))                                                                    #R cannot return multiple dataframes from a function. Therefore making a list with 2 dataframes.;
}








#Compiling all functions before running the simulations
distance <- cmpfun(distance)
anglefun <- cmpfun(anglefun)
ripen <- cmpfun(ripen)
fruitripening <- cmpfun(fruitripening)
fruitdecay <- cmpfun(fruitdecay)
fruiting <- cmpfun(fruiting)
scalarpropertyfun <- cmpfun(scalarpropertyfun)
decay <- cmpfun(decay)
fruiting <- cmpfun(fruiting)
move <- cmpfun(move)
Remembertemporal <- cmpfun(Remembertemporal)
forgetting <- cmpfun(forgetting)
discard_mem <- cmpfun(discard_mem)
move_primate <- cmpfun(move_primate)






######RUN SIMULATION######
#first simulation with only trees in order for there already to be some ripe fruits when the agents are in the simulations
#simulations with more than 540 iterations (i.e. average number of steps fruits need to ripen)
time_steps <- 3500
ts <- 0
Trees_hist<-NULL
while(ts < time_steps){
  
  ripeninglist<-fruitripening(Trees,Fruits)
  Trees <- ripeninglist[[1]]
  Fruits <- ripeninglist[[2]]

  decaylist<-fruitdecay(Trees,Fruits)
  Trees <- decaylist[[1]]
  Fruits <- decaylist[[2]]
  
  fruitinglist<-fruiting(Trees,Fruits)
  Trees <- fruitinglist[[1]]
  Fruits <- fruitinglist[[2]]
  
  ts   <- ts + 1; 
  Trees_hist[[ts]]<-Trees
}


 
#run the model for 9490 steps (half year = 365*0.5*13*4) 
ts <- 2
time_steps <- 7800 + ts
Agent_hist  <- NULL; # Here's the list with each location at the time steps
Primate_agent_hist  <- NULL; # Here's the list with each location at the time steps
Trees_hist<-NULL
Temporal_remembered_hist<-NULL



#this is in order for determining the angle to take
Primate_agent_hist[[1]] <- Primate_agent
Primate_agent_hist[[2]] <- Primate_agent
Agent_hist[[1]] <- Agent
Agent_hist[[2]] <- Agent



######RUN SIMULATION: PART2######
while(ts < time_steps){
  
  movementlist<-move(Agent,Trees, Fruits, Agent_hist, ts)
  Agent<-movementlist[[1]]
  Trees<-movementlist[[2]]
  Fruits<-movementlist[[3]]
  
  rm(movementlist)
  
  Temporal_remembered <- Remembertemporal(Primate_agent, Trees, Fruits, Temporal_remembered)
  
  movement_primatelist<- move_primate(Primate_agent, Trees, Fruits, Temporal_remembered, Primate_agent_hist, ts)
  Primate_agent       <- movement_primatelist[[1]]
  Trees               <- movement_primatelist[[2]]
  Fruits              <- movement_primatelist[[3]]
  Temporal_remembered <- movement_primatelist[[4]]
  
  rm(movement_primatelist)
  
  
  Temporal_remembered <- discard_mem(Primate_agent, Trees, Fruits, Temporal_remembered)
  
  
  Temporal_remembered <- forgetting(Temporal_remembered)
  
  
  ripeninglist<-fruitripening(Trees,Fruits)
  Trees <- ripeninglist[[1]]
  Fruits <- ripeninglist[[2]]
  
  rm(ripeninglist)
  
  decaylist<-fruitdecay(Trees,Fruits)
  Trees <- decaylist[[1]]
  Fruits <- decaylist[[2]]
  
  rm(decaylist)
  
  fruitinglist<-fruiting(Trees,Fruits)
  Trees <- fruitinglist[[1]]
  Fruits <- fruitinglist[[2]]
  
  rm(fruitinglist)
  
  ts   <- ts + 1; 
  Agent_hist[[ts]] <- Agent; # Add to list
  Primate_agent_hist[[ts]] <- Primate_agent; # Add to list
  Trees_hist[[ts]]<-Trees;
  Temporal_remembered_hist[[ts]]<- Temporal_remembered;
  
}





save.image(paste("~/Documents/ABM/Output/model", iteratie, ".RData"))

rm(Agent)
rm(Agent_hist)
rm(Primate_agent)
rm(Primate_agent_hist)
rm(Temporal_remembered)
rm(Temporal_remembered_hist)
rm(Tree2)
rm(Trees)
rm(Trees_hist)


iteratie<-iteratie+1
}





######Output######
#primate total eaten
Primate_agent[1,4]
#nr of fruits produced
sum(Trees[,10]); 







######Visualize movement:Agent1######
#extract locations of first competitor agent 
Agent1_locs <- array(data = NA, dim = c(time_steps, 3));
for(i in 1:time_steps){
  Agent1_locs[i, 1] <- i;                     # Save the time step
  Agent1_locs[i, 2] <- Agent_hist[[i]][1, 2]; # xloc for the time step
  Agent1_locs[i, 3] <- Agent_hist[[i]][1, 3]; # yloc for the time step
}
colnames(Agent1_locs) <- c("time_step", "x_loc", "y_loc");

#make it a dataframe
Agent1_locs <- as.data.frame(Agent1_locs)
print(Agent1_locs)


#plot movement of individual 1
library(ggplot2)

ggplot(Agent1_locs, aes(x = x_loc, y=y_loc, color=time_step )) + geom_point() + 
  geom_path(arrow = arrow(type = "closed", 
                          length = unit(0.008, "npc"))) +
  geom_point(data=as.data.frame(Trees), aes(x=Xcoord, y=Ycoord), color="green") #+ xlim(250, 300) + ylim(230, 260)








######Visualize movement:Primate Agent######
#extract locations of primate agent 
Primate_locs <- array(data = NA, dim = c(time_steps, 3));
for(i in 1:time_steps){
  Primate_locs[i, 1] <- i;                     # Save the time step
  Primate_locs[i, 2] <- Primate_agent_hist[[i]][1, 2]; # xloc for the time step
  Primate_locs[i, 3] <- Primate_agent_hist[[i]][1, 3]; # yloc for the time step
}
colnames(Primate_locs) <- c("time_step", "x_loc", "y_loc");

#make it a dataframe
Primate_locs <- as.data.frame(Primate_locs)
Primate_locs <- Primate_locs
print(Primate_locs) 


#plot movement of individual 1
library(ggplot2)

ggplot(Primate_locs, aes(x = x_loc, y=y_loc, color=time_step )) + geom_point() + 
  geom_path(arrow = arrow(type = "closed", 
                          length = unit(0.008, "npc"))) +
  geom_point(data=as.data.frame(Trees), aes(x=Xcoord, y=Ycoord), color="green") #+ xlim(250, 500) + ylim(0, 260)









#Basic checks---------------------------------
#Checking if code functions/has functioned properly

#Check1---------------------------------
#####checks if the total number of fruits eaten does not exceed the total number of fruits created. (After running abm)
if(sum(Trees[,10]) > (Primate_agent[1,4] + sum(Agent[,4]))){"Nice"}else{"Problem!"} #total number of fruits created - total number of fruits eaten. 



#Check2---------------------------------
#####check if scalarproperty function is functioning properly.#y_values gaan tot max 100.
high_b<-NULL
low_b<-NULL
zero_b<-NULL
for(i in 1:10000){
  high_b<-cbind(high_b,scalarpropertyfun(y_value=30, b_value=(100/3120),ripeningsteps = 3120 ,bwaarde=0.2))
  low_b<-cbind(low_b,scalarpropertyfun(y_value=30, b_value=(100/3120),ripeningsteps = 3120 , bwaarde=0.1))
  zero_b<-cbind(zero_b,scalarpropertyfun(y_value=30, b_value=(100/3120),ripeningsteps = 3120 , bwaarde=0.0))
}

# de spreiding zou hoger moeten zijn wanneer er hogere b_waardes worden gebruikt. 
if(sd(high_b)>sd(low_b)){"Nice"}else{"Problem!"}

#de spreading zou nul moeten zijn bij b_waarde van 0
if(sd(zero_b)==0){"Nice"}else{"Problem!"}



#Check3---------------------------------
#####check if scalarproperty function is functioning properly. if y-value is 95 it should be almost zero 
if(round(scalarpropertyfun(y_value=95,bwaarde=0.0), digits = 6)==0){"Nice"}else{"Problem!"}




#Check4---------------------------------


